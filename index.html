<!DOCTYPE html>
<html>
  <head>
    <title></title>
    <style>
      a { color: #44f !important; margin: 0 0.375rem; text-decoration: none }
      body { background: #f5f4f3; color: #444; font-family: sans-serif; line-height: 1.5rem; padding: 1.5rem; text-align: center }
      h3 { font-weight: 100; margin: 0.125rem; text-transform: lowercase; }
      p { margin: 0 }
      section { border-left: 1px solid #e4e6e8; border-right: 1px solid #e4e6e8; margin: 0; max-width: 30rem; padding: 1.5rem; width: 100% }
      section:nth-child(odd) { background: white }
      section:nth-child(even) { background: #f9f8f7 }
      section:first-child { border-radius: 0.25rem 0.25rem 0 0; border-top: 1px solid #e4e6e8;  }
      section:last-child { border-radius: 0 0 0.25rem 0.25rem; border-bottom: 1px solid #e4e6e8;  }
      div#container { display: flex; align-items: center; flex-direction: column; justify-content: center; }
    </style>
  </head>
  <body>
    <div id="container"></div>
    <script>
      // gateway check hash & test
      const CHECK_HASH = 'bafybeifx7yeb55armcsxwwitkymga5xf53dxiarykms3ygqic223w5sk3m';
      const CHECK_STRING = 'Hello from IPFS Gateway Checker';

      // base domain for IPNS
      const DOMAIN = 'dotapps.io';

      // alternative IPNS-capable gateways, [name, host]
      const GATEWAYS = [
        ['CloudFlare', 'https://cloudflare-ipfs.com'],
        ['Eternum', 'https://ipfs.eternum.io'],
        ['Pinata', 'https://gateway.pinata.cloud'],
        ['PrivacyTools', 'https://ipfs.privacytools.io'],
        ['Temporal', 'https://gateway.temporal.cloud']
      ];

      // timeout in seconds
      const TIMEOUT = 5;

      // create a link tag
      function createLink (text, host, path, linkId) {
        const a = document.createElement('a');

        a.appendChild(document.createTextNode(text));
        a.href = `${host}/${path}`;

        if (linkId) {
          a.setAttribute('id', linkId);
          a.style.display = 'none';
        }

        return a;
      }

      // create a section with a title and links as <section><h3>...</h3><p><a>...</a><a>...</a></p></section>
      function createSection (sectionId, title, links) {
        const section = document.createElement('section');
        const h = document.createElement('h3');
        const p = document.createElement('p');

        for (let i = 0; i < links.length; i++) {
          p.appendChild(links[i]);
        }

        h.appendChild(document.createTextNode(title));

        section.setAttribute('id', sectionId);
        section.appendChild(h);
        section.appendChild(p);

        document.getElementById('container').appendChild(section);
      }

      // parse the query, returning the chain
      function getChain () {
        const parts = window.location.search.substring(1).split('&').filter((p) => p);

        if (parts.length) {
          for (let i = 0; i < parts.length; i++) {
            if (parts[i].includes('=')) {
              const [key, value] = parts[i].split('=');

              if (key === 'chain') {
                return value;
              }
            } else {
              return parts[i];
            }
          }
        }

        return null;
      }

      // check a specific gateway for uptime
      async function checkGateway (host) {
        try {
          // check the content of the hash on the supplied host
          const result = await fetch(`${host}/ipfs/${CHECK_HASH}`);
          const text = await result.text();

          if (CHECK_STRING === text.trim()) {
            return true;
          }
        } catch (error) {
          console.error(error);
        }

        return false;
      }

      // lookup an ipfs hash based on the given ipns domain
      async function lookupHash (domain) {
        try {
          const result = await fetch(`https://ipfs.io/api/v0/name/resolve?arg=${domain}`);

          if (result.status !== 200) {
            throw new Error(`Received status=${result.status} on lookup`);
          }

          const { Path } = await result.json();

          return Path;
        } catch (error) {
          console.error(error);
        }

        return null;
      }

      function getRedirect (timeout) {
        return `Redirecting in ${(timeout / 10).toFixed(1)}s`
      }

      // main entry point
      async function main () {
        const chain = getChain();
        const ipns = `ipns/${chain ? `${chain}.` : ''}${DOMAIN}`;
        let timeout = TIMEOUT * 10;

        window.document.title = `Redirecting to ${ipns}`;

        createSection('redirect', getRedirect(timeout), [createLink(ipns, 'https://ipfs.io', ipns)]);

        setInterval(() => {
          const h3 = document.getElementById('redirect').querySelector('h3');

          if (--timeout <= 0) {
            h3.textContent = getRedirect(0);
            window.location.href = `https://ipfs.io/${ipns}`;
          } else {
            h3.textContent = getRedirect(timeout);
          }
        }, 100);

        // lookup the hash and add a section for it
        lookupHash(DOMAIN).then((path) => {
          if (path) {
            const hash = path.replace('/ipfs/', '');

            createSection('content', 'Link via content hash', [createLink(`${hash.substr(0, 8)}â€¦${hash.substr(-8)}`, 'https://ipfs.io', path)]);
          }
        });

        createSection('gateways', 'Alternative gateways', GATEWAYS.map(([title, host]) => createLink(title, host, ipns, title)));

        // loop through the gateways, adding them as they appear
        GATEWAYS.forEach(([title, host]) => {
          checkGateway(host).then((isUp) => {
            if (isUp) {
              const a = document.getElementById(title);

              a.style.display = 'inline';
            }
          })
        });
      }

      main().catch(console.error);
    </script>
  </body>
</html>
